<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Jaster</title>
    <link rel="stylesheet" href="app.css" type="text/css" />
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.1/css/bootstrap.css" type="text/css" />
    <link rel="stylesheet" href="wb.css" type="text/css" />
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/codemirror.css" type="text/css" />
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/theme/eclipse.css" type="text/css" />
    <!-- <script src="http://esprima.org/esprima.js"></script> -->
    <!-- <script src="http://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.15/require.js"></script> -->
    <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/lodash.js/2.4.1/lodash.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/codemirror.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/mode/javascript/javascript.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/mode/clike/clike.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/addon/edit/matchbrackets.js"></script>
    <!-- <script src="Scripts/mp.js"></script> -->
    <script src="http://cdnjs.cloudflare.com/ajax/libs/react/0.12.1/react-with-addons.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.1/js/bootstrap.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js"></script>
    <script src="app.js"></script>

    <script type="text/javascript">
    /*
    var state$ = lib.init(1);
    function vecAdd() {
      function vecAdd$gen_() {
        var functionStack$ = {}, functionName$ = 'vecAdd';
        functionStack$ = _.clone(arguments[1], true);
        functionStack$['state$'] = arguments[0];
        var state$ = functionStack$['state$'];
        functionStack$['threadIdx'] = arguments[2];
        var threadIdx = functionStack$['threadIdx'];
        functionStack$['blockIdx'] = arguments[3];
        var blockIdx = functionStack$['blockIdx'];
        functionStack$['blockDim'] = arguments[4];
        var blockDim = functionStack$['blockDim'];
        functionStack$['gridDim'] = arguments[5];
        var gridDim = functionStack$['gridDim'];
        functionStack$['in1'] = arguments[6];
        var in1 = functionStack$['in1'];
        lib.setType(functionStack$, 'in1', {
          type: 'ReferenceType',
          kind: {
            type: 'TypeExpression',
            addressSpace: [''],
            qualifiers: [],
            bases: ['float']
          }
        });
        functionStack$['in2'] = arguments[7];
        var in2 = functionStack$['in2'];
        lib.setType(functionStack$, 'in2', {
          type: 'ReferenceType',
          kind: {
            type: 'TypeExpression',
            addressSpace: [''],
            qualifiers: [],
            bases: ['float']
          }
        });
        functionStack$['out'] = arguments[8];
        var out = functionStack$['out'];
        lib.setType(functionStack$, 'out', {
          type: 'ReferenceType',
          kind: {
            type: 'TypeExpression',
            addressSpace: [''],
            qualifiers: [],
            bases: ['float']
          }
        });
        functionStack$['len'] = arguments[9];
        var len = functionStack$['len'];
        lib.setType(functionStack$, 'len', {
          type: 'TypeExpression',
          addressSpace: [''],
          qualifiers: [],
          bases: ['int']
        });
        return function vecAdd$f_(lineState$) {
          functionStack$['position'] = 8;
          if (lib.checkEvent(state$, worker$, functionStack$)) {
            lib.handleEvent(state$, worker$, functionStack$);
          }
          lib.setType(functionStack$, 'idx', {
            type: 'TypeExpression',
            addressSpace: [''],
            qualifiers: [],
            bases: ['int']
          }), functionStack$['idx'] = Math.floor(blockIdx.x * blockDim.x + threadIdx.x);
          var idx = functionStack$['idx'];
          functionStack$['position'] = 9;
          if (lib.checkEvent(state$, worker$, functionStack$)) {
            lib.handleEvent(state$, worker$, functionStack$);
          }
          functionStack$['cond$9'] = functionStack$['idx'] < functionStack$['len'];
          if (functionStack$['cond$9']) {
            functionStack$['position'] = 9;
            if (lib.checkEvent(state$, worker$, functionStack$)) {
              lib.handleEvent(state$, worker$, functionStack$);
            }
            lib.cuda.setElement(state$, functionStack$, lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'out')), functionStack$['idx'], lib.c.getElement(state$, functionStack$, lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'in1')), functionStack$['idx']) + lib.c.getElement(state$, functionStack$, lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'in2')), functionStack$['idx']));
          }
        };
      }
      var state$ = arguments[0], functionStack$ = arguments[1], worker$ = lib.initWorker(state$);
      var threadIdx = {
        x: 0,
        y: 0,
        z: 0
      }, threadFuns = [], threadStates = [], blockIdx = arguments[2], blockDim = arguments[3], gridDim = arguments[4];
      lib.setReference(state$, functionStack$, lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'in1')), arguments[5]);
      lib.setReference(state$, functionStack$, lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'in2')), arguments[6]);
      lib.setReference(state$, functionStack$, lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'out')), arguments[7]);
      var len = arguments[8];
      for (threadIdx['z'] = 0; threadIdx['z'] < (blockDim['z'] || 1); threadIdx['z']++) {
        for (threadIdx['y'] = 0; threadIdx['y'] < (blockDim['y'] || 1); threadIdx['y']++) {
          for (threadIdx['x'] = 0; threadIdx['x'] < (blockDim['x'] || 1); threadIdx['x']++) {
            threadStates.push('init');
            threadFuns.push(vecAdd$gen_(state$, functionStack$, {
              x: threadIdx['x'],
              y: threadIdx['y'],
              z: threadIdx['z']
            }, blockIdx, blockDim, gridDim, lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'in1')), lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'in2')), lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'out')), len));
          }
        }
      }
      return function () {
        while (_.all(_.map(threadFuns, function (threadFun, idx) {
          return threadStates[idx] = threadFun(threadStates[idx]);
        }), function (state) {
          return !_.isUndefined(state) && state !== 'finish';
        })) {
        }
      };
    }
    function main() {
      var functionStack$ = {}, functionName$ = 'main';
      functionStack$['argc'] = arguments[0];
      var argc = functionStack$['argc'];
      lib.setType(functionStack$, 'argc', {
        type: 'TypeExpression',
        addressSpace: [''],
        qualifiers: [],
        bases: ['int']
      });
      functionStack$['argv'] = arguments[1];
      var argv = functionStack$['argv'];
      lib.setType(functionStack$, 'argv', {
        type: 'ReferenceType',
        kind: {
          type: 'ReferenceType',
          kind: {
            type: 'TypeExpression',
            addressSpace: [''],
            qualifiers: [],
            bases: ['char']
          }
        }
      });
      var args = functionStack$['args'];
      lib.setType(functionStack$, 'inputLength', {
        type: 'TypeExpression',
        addressSpace: [''],
        qualifiers: [],
        bases: ['int']
      }), functionStack$['inputLength'] = undefined;
      var inputLength = functionStack$['inputLength'];
      lib.setType(functionStack$, 'hostInput1', {
        type: 'ReferenceType',
        kind: {
          type: 'TypeExpression',
          addressSpace: [''],
          qualifiers: [],
          bases: ['float']
        }
      }), functionStack$['hostInput1'] = undefined;
      var hostInput1 = functionStack$['hostInput1'];
      lib.setType(functionStack$, 'hostInput2', {
        type: 'ReferenceType',
        kind: {
          type: 'TypeExpression',
          addressSpace: [''],
          qualifiers: [],
          bases: ['float']
        }
      }), functionStack$['hostInput2'] = undefined;
      var hostInput2 = functionStack$['hostInput2'];
      lib.setType(functionStack$, 'hostOutput', {
        type: 'ReferenceType',
        kind: {
          type: 'TypeExpression',
          addressSpace: [''],
          qualifiers: [],
          bases: ['float']
        }
      }), functionStack$['hostOutput'] = undefined;
      var hostOutput = functionStack$['hostOutput'];
      lib.setType(functionStack$, 'deviceInput1', {
        type: 'ReferenceType',
        kind: {
          type: 'TypeExpression',
          addressSpace: [''],
          qualifiers: [],
          bases: ['float']
        }
      }), functionStack$['deviceInput1'] = undefined;
      var deviceInput1 = functionStack$['deviceInput1'];
      lib.setType(functionStack$, 'deviceInput2', {
        type: 'ReferenceType',
        kind: {
          type: 'TypeExpression',
          addressSpace: [''],
          qualifiers: [],
          bases: ['float']
        }
      }), functionStack$['deviceInput2'] = undefined;
      var deviceInput2 = functionStack$['deviceInput2'];
      lib.setType(functionStack$, 'deviceOutput', {
        type: 'ReferenceType',
        kind: {
          type: 'TypeExpression',
          addressSpace: [''],
          qualifiers: [],
          bases: ['float']
        }
      }), functionStack$['deviceOutput'] = undefined;
      var deviceOutput = functionStack$['deviceOutput'];
      functionStack$['args'] = lib.wb.wbArg_read(state$, functionStack$, functionStack$['argc'], lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'argv'))), args = functionStack$['args'];
      lib.wb.wbTime_start(state$, functionStack$, 'Generic', 'Importing data and creating memory on host');
      functionStack$['position'] = 2;
      if (lib.checkEvent(state$, functionStack$)) {
        lib.handleEvent(state$, functionStack$);
      }
      functionStack$['hostInput1'] = lib.c.makeReference(state$, functionStack$, 'hostInput1', lib.wb.wbImport(state$, functionStack$, 'input0', lib.reference(state$, functionStack$, 'inputLength'))), hostInput1 = functionStack$['hostInput1'];
      functionStack$['hostInput2'] = lib.c.makeReference(state$, functionStack$, 'hostInput2', lib.wb.wbImport(state$, functionStack$, 'input1', lib.reference(state$, functionStack$, 'inputLength'))), hostInput2 = functionStack$['hostInput2'];
      functionStack$['hostOutput'] = lib.c.makeReference(state$, functionStack$, 'hostOutput', lib.c.malloc(state$, functionStack$, functionStack$['inputLength'] * lib.c.sizeof(state$, functionStack$, 'float'), ['inputLength'])), hostOutput = functionStack$['hostOutput'];
      lib.wb.wbTime_stop(state$, functionStack$, 'Generic', 'Importing data and creating memory on host');
      lib.wb.wbLog(state$, functionStack$, 'TRACE', 'The input length is ', functionStack$['inputLength'], ' elements');
      lib.wb.wbTime_start(state$, functionStack$, 'GPU', 'Allocating GPU memory.');
      lib.setType(functionStack$, 'byteSize', {
        type: 'TypeExpression',
        addressSpace: [''],
        qualifiers: [],
        bases: ['int']
      }), functionStack$['byteSize'] = Math.floor(lib.c.sizeof(state$, functionStack$, 'float') * functionStack$['inputLength']);
      var byteSize = functionStack$['byteSize'];
      functionStack$['position'] = 37;
      if (lib.checkEvent(state$, functionStack$)) {
        lib.handleEvent(state$, functionStack$);
      }
      lib.wb.wbTime_stop(state$, functionStack$, 'GPU', 'Allocating GPU memory.');
      lib.wb.wbTime_start(state$, functionStack$, 'GPU', 'Copying input memory to the GPU.');
      lib.cuda.cudaMalloc(state$, functionStack$, lib.reference(state$, functionStack$, 'deviceInput1'), functionStack$['byteSize'], [
      'deviceInput1',
      'byteSize'
      ]);
      lib.cuda.cudaMalloc(state$, functionStack$, lib.reference(state$, functionStack$, 'deviceInput2'), functionStack$['byteSize'], [
      'deviceInput2',
      'byteSize'
      ]);
      lib.cuda.cudaMalloc(state$, functionStack$, lib.reference(state$, functionStack$, 'deviceOutput'), functionStack$['byteSize'], [
      'deviceOutput',
      'byteSize'
      ]);
      lib.wb.wbTime_stop(state$, functionStack$, 'GPU', 'Copying input memory to the GPU.');
      lib.cuda.cudaMemcpy(state$, functionStack$, lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'deviceInput1')), lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'hostInput1')), functionStack$['byteSize'], 'cudaMemcpyHostToDevice');
      functionStack$['position'] = 52;
      if (lib.checkEvent(state$, functionStack$)) {
        lib.handleEvent(state$, functionStack$);
      }
      lib.cuda.cudaMemcpy(state$, functionStack$, lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'deviceInput2')), lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'hostInput1')), functionStack$['byteSize'], 'cudaMemcpyHostToDevice');
      lib.wb.wbTime_start(state$, functionStack$, 'Compute', 'Performing CUDA computation');
      lib.setType(functionStack$, 'block_size', {
        type: 'TypeExpression',
        addressSpace: [''],
        qualifiers: [],
        bases: ['int']
      }), functionStack$['block_size'] = Math.floor(16);
      var block_size = functionStack$['block_size'];
      lib.setType(functionStack$, 'n_blocks', {
        type: 'TypeExpression',
        addressSpace: [''],
        qualifiers: [],
        bases: ['int']
      }), functionStack$['n_blocks'] = Math.floor(functionStack$['inputLength'] / functionStack$['block_size'] + (functionStack$['inputLength'] % functionStack$['block_size'] == 0 ? 0 : 1));
      var n_blocks = functionStack$['n_blocks'];
      var p_gridDim$ = [functionStack$['n_blocks']];
      var p_blockDim$ = [functionStack$['block_size']];
      var gridDim$ = {
        x: p_gridDim$.length > 0 ? p_gridDim$[0] : 1,
        y: p_gridDim$.length > 1 ? p_gridDim$[1] : 1,
        z: p_gridDim$.length > 2 ? p_gridDim$[2] : 1
      }, blockDim$ = {
        x: p_blockDim$.length > 0 ? p_blockDim$[0] : 1,
        y: p_blockDim$.length > 1 ? p_blockDim$[1] : 1,
        z: p_blockDim$.length > 2 ? p_blockDim$[2] : 1
      };
      for (var blockIdxZ = 0; blockIdxZ < gridDim$.z; ++blockIdxZ) {
        for (var blockIdxY = 0; blockIdxY < gridDim$.y; ++blockIdxY) {
          for (var blockIdxX = 0; blockIdxX < gridDim$.x; ++blockIdxX) {
            lib.parallel.scheduleThread(state$, function (state$, functionStack$, blockIdx$) {
              return function () {
                return vecAdd(state$, functionStack$, blockIdx$, blockDim$, gridDim$, lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'deviceInput1')), lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'deviceInput2')), lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'deviceOutput')), functionStack$['inputLength']);
              };
            }(state$, functionStack$, {
              x: blockIdxX,
              y: blockIdxY,
              z: blockIdxZ
            }));
          }
        }
      }
      lib.cuda.cudaThreadSynchronize(state$, functionStack$).then(function () {
        lib.wb.wbTime_stop(state$, functionStack$, 'Compute', 'Performing CUDA computation');
        lib.wb.wbTime_start(state$, functionStack$, 'Copy', 'Copying output memory to the CPU');
        functionStack$['position'] = 2;
        if (lib.checkEvent(state$, functionStack$)) {
          lib.handleEvent(state$, functionStack$);
        }
        lib.cuda.cudaMemcpy(state$, functionStack$, lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'hostOutput')), lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'deviceOutput')), functionStack$['byteSize'], 'cudaMemcpyDeviceToHost');
        lib.wb.wbTime_stop(state$, functionStack$, 'Copy', 'Copying output memory to the CPU');
        lib.wb.wbTime_start(state$, functionStack$, 'GPU', 'Freeing GPU Memory');
        lib.wb.wbTime_stop(state$, functionStack$, 'GPU', 'Freeing GPU Memory');
        lib.wb.wbSolution(state$, functionStack$, functionStack$['args'], lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'hostOutput')), functionStack$['inputLength']);
        lib.c.free(state$, functionStack$, lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'hostInput1')));
        functionStack$['position'] = 82;
        if (lib.checkEvent(state$, functionStack$)) {
          lib.handleEvent(state$, functionStack$);
        }
        lib.c.free(state$, functionStack$, lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'hostInput2')));
        lib.c.free(state$, functionStack$, lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'hostOutput')));
      }).done(function () {
        console.log('completed program execution');
      });
    }

  main([], 0);
  */
    </script>
</head>
<body>


  <header class="navbar navbar-inverse navbar-fixed-top bs-docs-nav" role="banner">
    <div class="container">
      <div class="navbar-header">
        <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          {{ if .user }}
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          {{ end }}
        </button>
        <a href="/" class="navbar-brand">
          WebGPU
          <!-- <small class="text-small text-danger">Beta</small> -->
        </a>
      </div>
      <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
        <ul class="nav navbar-nav navbar-left">
          <!--<li class="nav-index">
          <a href="/">Index</a>
        </li> -->
        <li class="nav-machineproblems dropdown">
          <a href="/#" class="dropdown-toggle" data-toggle="dropdown">Machine Problems <b class="caret"></b></a>
          <ul class="dropdown-menu">
            <!--
            <li><a href="/mp/0">Device Query</a></li>
            <li><a href="/mp/1">Vector Addition</a></li>
            <li><a href="/mp/2">Basic Matrix-Matrix Multiplication</a></li>
            <li><a href="/mp/3">Tiled Matrix-Matrix Multiplication</a></li>
            <li><a href="/mp/6">Image Convolution</a></li>
            <li><a href="/mp/4">List Reduction</a></li>
            <li><a href="/mp/5">List Scan</a></li>
            <li><a href="/mp/11">Histograms</a></li>
            <li><a href="/mp/12">Vector Addition with Streams</a></li>
            <li><a href="/mp/7">Vector Addition (OpenCL)</a></li>
            <li><a href="/mp/8" class="hidden">Tiled Matrix-Matrix Multiplication (C++AMP)</a></li>
            <li><a href="/mp/9">Vector Addition (OpenACC)</a></li>
          -->
          <li><a href="/mp/0">Device Query</a></li>
          <li><a href="/mp/21">Scatter to Gather</a></li>
          <!--
          <li><a href="/mp/22">Register Tiled Convolution</a></li>
          <li><a href="/mp/23">Register Tiled SGEMM</a></li>
          <li><a href="/mp/24">Input Binning</a></li>
          <li><a href="/mp/25">BFS Queueing</a></li>
        -->
      </ul>
    </li>
    <li class="nav-attempts dropdown">
      <a href="/#" class="dropdown-toggle" data-toggle="dropdown">Attempts <b class="caret"></b></a>
      <ul class="dropdown-menu">
        <!--
        <li><a href="/mp/0/attempts">Device Query</a></li>
        <li><a href="/mp/1/attempts">Vector Addition</a></li>
        <li><a href="/mp/2/attempts">Basic Matrix-Matrix Multiplication</a></li>
        <li><a href="/mp/3/attempts">Tiled Matrix-Matrix Multiplication</a></li>
        <li><a href="/mp/6/attempts">Image Convolution</a></li>
        <li><a href="/mp/4/attempts">List Reduction</a></li>
        <li><a href="/mp/5/attempts">List Scan</a></li>
        <li><a href="/mp/11/attempts">Histogram</a></li>
        <li><a href="/mp/12/attempts">Vector Addition with Streams</a></li>
        <li><a href="/mp/7/attempts">Vector Addition (OpenCL)</a></li>
        <li><a href="/mp/8/attempts" class="hidden">Tiled Matrix-Matrix Multiplication (C++AMP)</a></li>
        <li><a href="/mp/9/attempts">Vector Addition (OpenACC)</a></li>
      -->
      <li><a href="/mp/0/attempts">Device Query</a></li>
      <li><a href="/mp/21/attempts">Scatter to Gather</a></li>
      <!--
      <li><a href="/mp/22/attempts">Register Tiled Convolution</a></li>
      <li><a href="/mp/23/attempts">Register Tiled SGEMM</a></li>
      <li><a href="/mp/24/attempts">Input Binning</a></li>
      <li><a href="/mp/25/attempts">BFS Queueing</a></li>
    -->
  </ul>
</li>
<!--
<li class="nav-peerreview dropdown">
<a href="/#" class="dropdown-toggle" data-toggle="dropdown">Peer Review <b class="caret"></b></a>
<ul class="dropdown-menu">
<li><a href="/mp/0/peerreview">Device Query</a></li>
<li><a href="/mp/1/peerreview">Vector Addition</a></li>
<li><a href="/mp/2/peerreview">Basic Matrix-Matrix Multiplication</a></li>
<li><a href="/mp/3/peerreview">Tiled Matrix-Matrix Multiplication</a></li>
<li><a href="/mp/6/peerreview">Image Convolution</a></li>
<li><a href="/mp/4/peerreview">List Reduction</a></li>
<li><a href="/mp/5/peerreview">List Scan</a></li>
<li><a href="/mp/11/peerreview">Histogram</a></li>
<li><a href="/mp/12/peerreview">Vector Addition with Streams</a></li>
<li><a href="/mp/7/peerreview">Vector Addition (OpenCL)</a></li>
<li><a href="/mp/8/peerreview" class="hidden">Tiled Matrix-Matrix Multiplication (C++AMP)</a></li>
<li><a href="/mp/9/peerreview">Vector Addition (OpenACC)</a></li>
</ul>
</li>
-->
<li class="nav-grades dropdown">
  <a href="/#" class="dropdown-toggle" data-toggle="dropdown">Grades <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <!--
    <li><a href="/grades/0">Device Query</a></li>
    <li><a href="/grades/1">Vector Addition</a></li>
    <li><a href="/grades/2">Basic Matrix-Matrix Multiplication</a></li>
    <li><a href="/grades/3">Tiled Matrix-Matrix Multiplication</a></li>
    <li><a href="/grades/6">Image Convolution</a></li>
    <li><a href="/grades/4">List Reduction</a></li>
    <li><a href="/grades/5">List Scan</a></li>
    <li><a href="/grades/11">Histogram</a></li>
    <li><a href="/grades/12">Vector Addition with Streams</a></li>
    <li><a href="/grades/7">Vector Addition (OpenCL)</a></li>
    <li><a href="/grades/8" class="hidden">Tiled Matrix-Matrix Multiplication (C++AMP)</a></li>
    <li><a href="/grades/9">Vector Addition (OpenACC)</a></li>
  -->
  <li><a href="/grades/0">Device Query</a></li>
  <li><a href="/grades/21">Scatter to Gather</a></li>
  <!--
  <li><a href="/grades/22">Register Tiled Convolution</a></li>
  <li><a href="/grades/23">Register Tiled SGEMM</a></li>
  <li><a href="/grades/24">Input Binning</a></li>
  <li><a href="/grades/25">BFS Queueing</a></li>
-->
</ul>
</li>

</ul>
<ul class="nav navbar-nav navbar-right">

  <li class="nav-machineproblems dropdown">
    <a href="/#" class="dropdown-toggle" data-toggle="dropdown">Help <b class="caret"></b></a>
    <ul class="dropdown-menu">
      <li><a href="/help">Tutorial</a></li>
      <li class="divider"></li>
      <li><a href="http://github.com/abduld/libwb">Local Development</a></li>
      <li><a href="http://github.com/abduld/wb/issues">Report Issues</a></li>
      <li class="divider"></li>
      <li><a href="/reset_password">Reset Password</a></li>
    </ul>
  </li>

<li class="nav-login navbar-left">
  <a href="/login">Login</a>
</li>
<li class="nav-login navbar-left">
  <a href="/signup">Signup</a>
</li>
</ul>
</nav>

</div>
</header>








<br/>

<div class="container">
    <div class="row clearfix hidden">
        <div class="col-lg-12 column">
            <div class="jumbotron">
                <h1>
                    Jaster
                </h1>
                <h2>
                    A CUDA to JavaScript Transcompiler
                </h2>
            </div>
        </div>
    </div>
    <div class="row clearfix">
      <div id="visualization"></div>
    </div>
    <div class="row clearfix hidden" id ="code-area">
        <div class="col-lg-6 column hidden">
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">
                        Input CUDA Code
                    </h3>
                </div>
                <div class="panel-body">
                    <textarea id="cuda-code" rows="90"></textarea>
                </div>
                <div class="panel-footer">
                    <button type="button" class="btn btn-default">Generate</button>
                </div>
            </div>
        </div>
        <div class="col-lg-12 column">
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">
                        JavaScript Equivalent
                    </h3>
                </div>
                <div class="panel-body">
                    <textarea id="js-code" rows="90"></textarea>
                </div>
            </div>
        </div>
    </div>
</div>
</body>
</html>
