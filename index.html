<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Jaster</title>
    <link rel="stylesheet" href="app.css" type="text/css" />
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.1/css/bootstrap.css" type="text/css" />
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.1/css/bootstrap-theme.css" type="text/css" />
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/codemirror.css" type="text/css" />
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/theme/eclipse.css" type="text/css" />
    <!-- <script src="http://esprima.org/esprima.js"></script> -->
    <!-- <script src="http://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.15/require.js"></script> -->
    <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/lodash.js/2.4.1/lodash.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/codemirror.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/mode/javascript/javascript.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/mode/clike/clike.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/codemirror/4.8.0/addon/edit/matchbrackets.js"></script>
    <!-- <script src="Scripts/mp.js"></script> -->
    <script src="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.1/js/bootstrap.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/q.js/1.1.2/q.js"></script>
    <script src="app.js"></script>
    <script type="text/javascript">

    var state$ = lib.init();
    function vecAdd() {
      function vecAdd$gen_() {
        var functionStack$ = {}, functionName$ = 'vecAdd';
        functionStack$['state$'] = arguments[0];
        functionStack$['threadIdx'] = arguments[1];
        functionStack$['blockIdx'] = arguments[2];
        functionStack$['blockDim'] = arguments[3];
        functionStack$['gridDim'] = arguments[4];
        functionStack$['in1'] = arguments[5];
        lib.setType(functionStack$, 'in1', {
          type: 'ReferenceType',
          kind: {
            type: 'TypeExpression',
            addressSpace: [''],
            qualifiers: [],
            bases: ['float']
          }
        });
        functionStack$['in2'] = arguments[6];
        lib.setType(functionStack$, 'in2', {
          type: 'ReferenceType',
          kind: {
            type: 'TypeExpression',
            addressSpace: [''],
            qualifiers: [],
            bases: ['float']
          }
        });
        functionStack$['out'] = arguments[7];
        lib.setType(functionStack$, 'out', {
          type: 'ReferenceType',
          kind: {
            type: 'TypeExpression',
            addressSpace: [''],
            qualifiers: [],
            bases: ['float']
          }
        });
        functionStack$['len'] = arguments[8];
        lib.setType(functionStack$, 'len', {
          type: 'TypeExpression',
          addressSpace: [''],
          qualifiers: [],
          bases: ['int']
        });
        return function vecAdd$f_(lineState$) {
          functionStack$['position'] = 8;
          if (lib.checkEvent(state$, worker$, functionStack$)) {
            lib.handleEvent(state$, worker$, functionStack$);
          }
          lib.setType(functionStack$, 'idx', {
            type: 'TypeExpression',
            addressSpace: [''],
            qualifiers: [],
            bases: ['int']
          }), functionStack$['idx'] = Math.floor(blockIdx.x * blockDim.x + threadIdx.x);
          var idx = functionStack$['idx'];
          functionStack$['position'] = 9;
          if (lib.checkEvent(state$, worker$, functionStack$)) {
            lib.handleEvent(state$, worker$, functionStack$);
          }
          functionStack$['cond$9'] = functionStack$['idx'] < functionStack$['len'];
          if (functionStack$['cond$9']) {
            functionStack$['position'] = 9;
            if (lib.checkEvent(state$, worker$, functionStack$)) {
              lib.handleEvent(state$, worker$, functionStack$);
            }
            lib.cuda.setElement(state$, functionStack$, lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'out')), functionStack$['idx'], lib.c.getElement(state$, lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'in1')), functionStack$['idx']) + lib.c.getElement(state$, lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'in2')), functionStack$['idx']));
          }
        };
      }
      var state$ = arguments[0], functionStack$ = arguments[1], worker$ = lib.initWorker(state$);
      var threadIdx = {
        x: 0,
        y: 0,
        z: 0
      }, threadFuns = [], threadStates = [], blockIdx = arguments[2], blockDim = arguments[3], gridDim = arguments[4];
      lib.setReference(lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'in1')), arguments[5]);
      lib.setReference(lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'in2')), arguments[6]);
      lib.setReference(lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'out')), arguments[7]);
      var len = arguments[7];
      for (threadIdx['z'] = 0; threadIdx['z'] < (blockDim['z'] || 1); threadIdx['z']++) {
        for (threadIdx['y'] = 0; threadIdx['y'] < (blockDim['y'] || 1); threadIdx['y']++) {
          for (threadIdx['x'] = 0; threadIdx['x'] < (blockDim['x'] || 1); threadIdx['x']++) {
            threadStates.push('init');
            threadFuns.push(vecAdd$gen_(state$, threadIdx, blockIdx, blockDim, gridDim, lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'in1')), lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'in2')), lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'out')), len));
          }
        }
      }
      return function () {
        while (_.all(_.map(threadFuns, function (threadFun, idx) {
          return threadStates[idx] = threadFun(threadStates[idx]);
        }), function (state) {
          return !_.isUndefined(state) && state !== 'finish';
        })) {
        }
      };
    }
    function main() {
      var functionStack$ = {}, functionName$ = 'main';
      functionStack$['argc'] = arguments[0];
      lib.setType(functionStack$, 'argc', {
        type: 'TypeExpression',
        addressSpace: [''],
        qualifiers: [],
        bases: ['int']
      });
      functionStack$['argv'] = arguments[1];
      lib.setType(functionStack$, 'argv', {
        type: 'ReferenceType',
        kind: {
          type: 'ReferenceType',
          kind: {
            type: 'TypeExpression',
            addressSpace: [''],
            qualifiers: [],
            bases: ['char']
          }
        }
      });
      lib.setType(functionStack$, 'args', {
        type: 'TypeExpression',
        addressSpace: [''],
        qualifiers: [],
        bases: ['int']
      }), functionStack$['args'] = undefined;
      var args = functionStack$['args'];
      lib.setType(functionStack$, 'inputLength', {
        type: 'TypeExpression',
        addressSpace: [''],
        qualifiers: [],
        bases: ['int']
      }), functionStack$['inputLength'] = undefined;
      var inputLength = functionStack$['inputLength'];
      lib.setType(functionStack$, 'hostInput1', {
        type: 'ReferenceType',
        kind: {
          type: 'TypeExpression',
          addressSpace: [''],
          qualifiers: [],
          bases: ['float']
        }
      }), functionStack$['hostInput1'] = undefined;
      var hostInput1 = functionStack$['hostInput1'];
      lib.setType(functionStack$, 'hostInput2', {
        type: 'ReferenceType',
        kind: {
          type: 'TypeExpression',
          addressSpace: [''],
          qualifiers: [],
          bases: ['float']
        }
      }), functionStack$['hostInput2'] = undefined;
      var hostInput2 = functionStack$['hostInput2'];
      lib.setType(functionStack$, 'hostOutput', {
        type: 'ReferenceType',
        kind: {
          type: 'TypeExpression',
          addressSpace: [''],
          qualifiers: [],
          bases: ['float']
        }
      }), functionStack$['hostOutput'] = undefined;
      var hostOutput = functionStack$['hostOutput'];
      lib.setType(functionStack$, 'deviceInput1', {
        type: 'ReferenceType',
        kind: {
          type: 'TypeExpression',
          addressSpace: [''],
          qualifiers: [],
          bases: ['float']
        }
      }), functionStack$['deviceInput1'] = undefined;
      var deviceInput1 = functionStack$['deviceInput1'];
      lib.setType(functionStack$, 'deviceInput2', {
        type: 'ReferenceType',
        kind: {
          type: 'TypeExpression',
          addressSpace: [''],
          qualifiers: [],
          bases: ['float']
        }
      }), functionStack$['deviceInput2'] = undefined;
      var deviceInput2 = functionStack$['deviceInput2'];
      lib.setType(functionStack$, 'deviceOutput', {
        type: 'ReferenceType',
        kind: {
          type: 'TypeExpression',
          addressSpace: [''],
          qualifiers: [],
          bases: ['float']
        }
      }), functionStack$['deviceOutput'] = undefined;
      var deviceOutput = functionStack$['deviceOutput'];
      functionStack$['args'] = lib.wb.wbArg_read(state$, functionStack$, functionStack$['argc'], lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'argv'))), args = functionStack$['args'];
      lib.wb.wbTime_start(state$, functionStack$, 'Generic', 'Importing data and creating memory on host');
      functionStack$['position'] = 2;
      if (lib.checkEvent(state$, functionStack$)) {
        lib.handleEvent(state$, functionStack$);
      }
      functionStack$['hostInput1'] = lib.c.makeReference(state$, functionStack$, 'hostInput1', lib.wb.wbImport(state$, functionStack$, 'input0', lib.reference(state$, functionStack$, 'inputLength'))), hostInput1 = functionStack$['hostInput1'];
      functionStack$['hostInput2'] = lib.c.makeReference(state$, functionStack$, 'hostInput2', lib.wb.wbImport(state$, functionStack$, 'input1', lib.reference(state$, functionStack$, 'inputLength'))), hostInput2 = functionStack$['hostInput2'];
      functionStack$['hostOutput'] = lib.c.makeReference(state$, functionStack$, 'hostOutput', lib.c.malloc(state$, functionStack$, functionStack$['inputLength'] * lib.c.sizeof(state$, functionStack$, 'float'), ['inputLength'])), hostOutput = functionStack$['hostOutput'];
      lib.wb.wbTime_stop(state$, functionStack$, 'Generic', 'Importing data and creating memory on host');
      lib.wb.wbLog(state$, functionStack$, 'TRACE', 'The input length is ', functionStack$['inputLength'], ' elements');
      lib.wb.wbTime_start(state$, functionStack$, 'GPU', 'Allocating GPU memory.');
      lib.setType(functionStack$, 'byteSize', {
        type: 'TypeExpression',
        addressSpace: [''],
        qualifiers: [],
        bases: ['int']
      }), functionStack$['byteSize'] = Math.floor(lib.c.sizeof(state$, functionStack$, 'float') * functionStack$['inputLength']);
      var byteSize = functionStack$['byteSize'];
      functionStack$['position'] = 37;
      if (lib.checkEvent(state$, functionStack$)) {
        lib.handleEvent(state$, functionStack$);
      }
      lib.wb.wbTime_stop(state$, functionStack$, 'GPU', 'Allocating GPU memory.');
      lib.wb.wbTime_start(state$, functionStack$, 'GPU', 'Copying input memory to the GPU.');
      lib.cuda.cudaMalloc(state$, functionStack$, lib.reference(state$, functionStack$, 'deviceInput1'), functionStack$['byteSize'], [
      'deviceInput1',
      'byteSize'
      ]);
      lib.cuda.cudaMalloc(state$, functionStack$, lib.reference(state$, functionStack$, 'deviceInput2'), functionStack$['byteSize'], [
      'deviceInput2',
      'byteSize'
      ]);
      lib.cuda.cudaMalloc(state$, functionStack$, lib.reference(state$, functionStack$, 'deviceOutput'), functionStack$['byteSize'], [
      'deviceOutput',
      'byteSize'
      ]);
      lib.wb.wbTime_stop(state$, functionStack$, 'GPU', 'Copying input memory to the GPU.');
      lib.cuda.cudaMemcpy(state$, functionStack$, lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'deviceInput1')), lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'hostInput1')), functionStack$['byteSize'], 'cudaMemcpyHostToDevice');
      functionStack$['position'] = 52;
      if (lib.checkEvent(state$, functionStack$)) {
        lib.handleEvent(state$, functionStack$);
      }
      lib.cuda.cudaMemcpy(state$, functionStack$, lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'deviceInput2')), lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'hostInput1')), functionStack$['byteSize'], 'cudaMemcpyHostToDevice');
      lib.wb.wbTime_start(state$, functionStack$, 'Compute', 'Performing CUDA computation');
      lib.setType(functionStack$, 'block_size', {
        type: 'TypeExpression',
        addressSpace: [''],
        qualifiers: [],
        bases: ['int']
      }), functionStack$['block_size'] = Math.floor(16);
      var block_size = functionStack$['block_size'];
      lib.setType(functionStack$, 'n_blocks', {
        type: 'TypeExpression',
        addressSpace: [''],
        qualifiers: [],
        bases: ['int']
      }), functionStack$['n_blocks'] = Math.floor(functionStack$['inputLength'] / functionStack$['block_size'] + (functionStack$['inputLength'] % functionStack$['block_size'] == 0 ? 0 : 1));
      var n_blocks = functionStack$['n_blocks'];
      var p_gridDim$ = [functionStack$['n_blocks']];
      var p_blockDim$ = [functionStack$['block_size']];
      var gridDim$ = {
        x: p_gridDim$.length > 0 ? p_gridDim$[0] : 1,
        y: p_gridDim$.length > 1 ? p_gridDim$[1] : 1,
        z: p_gridDim$.length > 2 ? p_gridDim$[2] : 1
      }, blockDim$ = {
        x: p_blockDim$.length > 0 ? p_blockDim$[0] : 1,
        y: p_blockDim$.length > 1 ? p_blockDim$[1] : 1,
        z: p_blockDim$.length > 2 ? p_blockDim$[2] : 1
      };
      for (var blockIdxZ = 0; blockIdxZ < gridDim$.z; ++blockIdxZ) {
        for (var blockIdxY = 0; blockIdxY < gridDim$.y; ++blockIdxY) {
          for (var blockIdxX = 0; blockIdxX < gridDim$.x; ++blockIdxX) {
            lib.parallel.scheduleThread(state$, function (state$, functionStack$, blockIdx$) {
              return function () {
                return vecAdd(state$, functionStack$, blockIdx$, blockDim$, gridDim$, lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'deviceInput1')), lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'deviceInput2')), lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'deviceOutput')), functionStack$['inputLength']);
              };
            }(state$, functionStack$, {
              x: blockIdxX,
              y: blockIdxY,
              z: blockIdxZ
            }));
          }
        }
      }
      lib.cuda.cudaThreadSynchronize(state$, functionStack$);
      lib.wb.wbTime_stop(state$, functionStack$, 'Compute', 'Performing CUDA computation');
      lib.wb.wbTime_start(state$, functionStack$, 'Copy', 'Copying output memory to the CPU');
      functionStack$['position'] = 2;
      if (lib.checkEvent(state$, functionStack$)) {
        lib.handleEvent(state$, functionStack$);
      }
      lib.cuda.cudaMemcpy(state$, functionStack$, lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'hostOutput')), lib.reference(state$, functionStack$, lib.cudaReference(state$, functionStack$, 'deviceOutput')), functionStack$['byteSize'], 'cudaMemcpyDeviceToHost');
      lib.wb.wbTime_stop(state$, functionStack$, 'Copy', 'Copying output memory to the CPU');
      lib.wb.wbTime_start(state$, functionStack$, 'GPU', 'Freeing GPU Memory');
      lib.wb.wbTime_stop(state$, functionStack$, 'GPU', 'Freeing GPU Memory');
      lib.wb.wbSolution(state$, functionStack$, functionStack$['args'], lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'hostOutput')), functionStack$['inputLength']);
      lib.c.free(state$, functionStack$, lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'hostInput1')));
      functionStack$['position'] = 82;
      if (lib.checkEvent(state$, functionStack$)) {
        lib.handleEvent(state$, functionStack$);
      }
      lib.c.free(state$, functionStack$, lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'hostInput2')));
      lib.c.free(state$, functionStack$, lib.reference(state$, functionStack$, lib.reference(state$, functionStack$, 'hostOutput')));
      return 0;
    }



  main([], 0);
    </script>
</head>
<body>
<div class="container">
    <div class="row clearfix hidden">
        <div class="col-lg-12 column">
            <div class="jumbotron">
                <h1>
                    Jaster
                </h1>
                <h2>
                    A CUDA to JavaScript Transcompiler
                </h2>
            </div>
        </div>
    </div>
    <div class="row clearfix">
        <div class="col-lg-6 column hidden">
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">
                        Input CUDA Code
                    </h3>
                </div>
                <div class="panel-body">
                    <textarea id="cuda-code" rows="90"></textarea>
                </div>
                <div class="panel-footer">
                    <button type="button" class="btn btn-default">Generate</button>
                </div>
            </div>
        </div>
        <div class="col-lg-12 column">
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title">
                        JavaScript Equivalent
                    </h3>
                </div>
                <div class="panel-body">
                    <textarea id="js-code" rows="90"></textarea>
                </div>
            </div>
        </div>
    </div>
</div>
</body>
</html>
